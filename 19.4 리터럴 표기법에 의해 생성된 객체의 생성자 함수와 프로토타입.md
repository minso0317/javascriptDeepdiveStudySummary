생성자 함수에 의해 생성된 인스턴스는 프로토타입의 constructor 프로퍼티에 의해 생성자 함수와 연결된다.

이때 constructor 프로퍼티가 가리키는 생성자 함수는 인스턴스를 생성한 생성자 함수다.

```jsx
// obj 객체를 생성한 생성자 함수는 Object다.
const obj = new Object();
console.log(obj.constructor === Object); // true

// add 함수 객체를 생성한 생성자 함수는 Function이다.
const add = new Function('a', 'b', 'return a + b');
console.log(add.constructor === Function); // true

// 생성자 함수
function Person(name) {
  this.name = name;
}

// me 객체를 생성한 생성자 함수는 Person이다.
const me = new Person('Lee');
console.log(me.constructor === Person); // true
```

리터럴 표기법에 의한 객체 생성 방식과 같이 명시적으로 new 연산자와 함께 생성자 함수를 호출하여 인스턴스를 생성하지 않는 객체 생성 방식도 있다.

```jsx
// 객체 리터럴
const obj = {};

// 함수 리터럴
const add = function (a, b) { return a + b; };

// 배열 리터럴
const arr = [1, 2, 3];

// 정규표현식 리터럴
const regexp = /is/ig;
```

리터럴 표기법에 의헤 생성된 객체도 프로토타입이 있다.

하지만 리터럴 표기법에 의해 생성된 객체의 프로토타입도 constructor 프로퍼티가 가리키는 생성자가 반드시 생성자 함수라고 단정할 수 없다.

```jsx
// obj 객체는 Object 생성자 함수로 생성한 객체가 아니라 객체 리터럴로 생성했다.
const obj = {};

// 하지만 obj 객체의 생성자 함수는 Object 생성자 함수다.
console.log(obj.constructor === Object); // true
```

```jsx
// Object 생성자 함수
19.1.1.1 Object ( [ value ] )
When the Object function is called with optional argument value, the following steps are taken:

If NewTarget is neither undefined nor the active function, then
Return ? OrdinaryCreateFromConstructor(NewTarget, "%Object.prototype%").
If value is undefined or null, return OrdinaryObjectCreate(%Object.prototype%).
Return ! ToObject(value).
The "length" property of the Object constructor function is 1.
```

2에서 Object  생성자 함수에 인수를 전달하지 않거나 undefined 또는 null을 인수로 전달하면서 호출하면 내부적으로 추상 연산 OrdinaryObjectCreate를 호출하여 Object.prototype을 프로토타입으로 갖는 빈 객체를 생성한다.

```jsx
// 2. Object 생성자 함수에 의한 객체 생성
// 인수가 전달되지 않았을 때 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성한다.
let obj = new Object();
console.log(obj); // {}

// 1. new.target이 undefined나 Object가 아닌 경우
// 인스턴스 -> Foo.prototype -> Object.prototype 순으로 프로토타입 체인이 생성된다.
class Foo extends Object {}
new Foo(); // Foo {}

// 3. 인수가 전달된 경우에는 인수를 객체로 변환한다.
// Number 객체 생성
obj = new Object(123);
console.log(obj); // Number {123}

// String  객체 생성
obj = new Object('123');
console.log(obj); // String {"123"}
```

객체 리터럴이 평가될 때는 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하고 프로퍼티를 추가하도록 정의된다.

```jsx
12.2.6.7 Runtime Semantics: Evaluation
ObjectLiteral:{}
Return OrdinaryObjectCreate(%Object.prototype%).
ObjectLiteral:
{PropertyDefinitionList}
{PropertyDefinitionList,}
Let obj be OrdinaryObjectCreate(%Object.prototype%).
Perform ? PropertyDefinitionEvaluation of PropertyDefinitionList with arguments obj and true.
Return obj.
```

Object 생성자 함수 호출과 객체 리터럴의 평가는 추상 연산 OrdinaryObjectCreate를 호출하여 빈 객체를 생성하는 점에서 동일하나 new.target의 확인이나 프로퍼티를 추가하는 처리 등 세부 내용이 다르다.

따라서 객체 리터럴에 의해 생성된 객체는 Object 생성자 함수가 생성한 객체가 아니다.

Function 생성자 함수로 만든 함수는 렉시컬 스코프나 클로저를 만들지 않고 전역 함수처럼 스코프를 생성하며 클로저도 만들지 않는다.

함수 선언문이나 함수 표현식으로 만든 함수는 Function 생성자 함수가 아니지만, constructor 프로퍼티를 통해 확인하면 Function 생성자 함수다.

```jsx
// foo 함수는 Function 생성자 함수로 생성한 함수 객체가 아니라 함수 선언문으로 생성했다.
function foo() {}

// 하지만 constructor 프로퍼티를 통해 확인해보면 함수 foo의 생성자 함수는 Function 생성자 함수다.
console.log(foo.constructor === Function); // true
```

리터럴 표기법(객체 리터럴, 함수 리터럴 등)으로 생성된 객체도 내부적으로는 가상의 생성자 함수와 연결되어 있으며, 이 생성자 함수는 constructor와 prototype으로 연결된다.

즉, 리터럴로 만든 객체와 생성자 함수로 만든 객체는 생성 방식에 차이가 있을 뿐, 본질적인 동작(프로토타입 상속 포함)은 동일하다.

| **리터럴 표기법** | **생성자 함수** | **프로토타입 객체** |
| --- | --- | --- |
| 객체 리터럴 `{}` | `Object` | `Object.prototype` |
| 함수 리터럴 `function(){}` | `Function` | `Function.prototype` |
| 배열 리터럴 `[]` | `Array` | `Array.prototype` |
| 정규 표현식 리터럴 `/ab+c/` | `RegExp` | `RegExp.prototype` |
