변수의 스코프는 좁을수록 좋다. 

전역 변수를 무분별하게 남발하여 사용하는 것을 억제해야 한다.

아래에 전역 변수의 사용을 억제하는 몇 가지 방법이 있다.
<br><br>

### 14.3.1 즉시 실행 함수

모든 코드를 즉시 실행 함수로 감싸면 모든 변수는 즉시 실행 함수의 지역 변수가 된다.

```jsx
// 즉시 실행 함수(이 방법은 전역 변수를 생성하지 않아 라이브러리 등에 자주 사용된다.
(function () {
  var foo = 10; // 즉시 실행 함수의 지역 변수
  // ...
}());

console.log(foo); // ReferenceError: foo is not defined
```

<br><br>

### 14.3.2 네임스페이스 객체

전역에 네임스페이스(namespace)역할을 할 객체를 생성하고 전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다.

```jsx
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.name = 'Lee';

console.log(MYAPP.name); // Lee
```

네임스페이스 객체에 또 다른 네임스페이스 객체를 프로퍼티로 추가해서 네임스페이스를 계층적으로 구성할 수도 있다.

```jsx
var MYAPP = {}; // 전역 네임스페이스 객체

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(MYAPP.person.name); // Lee
```

네임 스페이스를 분리해서 식별자 충동을 발지할 수 있으니 네임스페이스 객체 자체가 전역 변수에 할당되므로 그다지 유용하진 않다.
<br><br>

### 14.3.3 모듈 패턴

모듈 패턴은 관련 변수와 함수를 클로저로 감싸 하나의 모듈로 만드는 방식으로, 클래스를 모방해 전역 변수 오염을 방지하고 캡슐화(정보 은닉)를 실현할 수 있다. 

자바스크립트는 public, private, protected 같은 접근 제어자를 제공하지 않지만, 모듈 패턴을 통해 내부 상태와 동작을 외부에서 숨길 수 있다. 

이는 자바스크립트의 클로저(closure) 기능을 기반으로 동작합니다.

```jsx
var Counter = (function () {
  // private 변수
  var num = 0;

  // 외부로 공개할 데이터나 메서드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  };
}());

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num); // undefined

console.log(Counter.increase()); // 1
console.log(Counter.increase()); // 2
console.log(Counter.decrease()); // 1
console.log(Counter.decrease()); // 0
```

위 코드의 즉시 실행 함수는 객체를 반환한다. 이 객체는 외부에 노출하고 싶은 변수나 함수를 담아 반환한다. 이 때 반환되는 객체의 프로퍼티는 외부에 노출되는 퍼블릭 멤버(public member)다.

외부에 노출하고 싶지 않은 변수나 함수는 반환하는 객체에 추가하지 않으면 외부에서 접근할 수 없는 프라이빗 멤버(private member)가 된다.
<br><br>

### 14.3.4 ES6 모듈

ES6 모듈은 파일 자체의 독자적인 모듈 스코프를 제공한다.

따라서 모듈 내에서 var 키워드로 선언한 변수는 더 이상 전역 변수가 아니고 window 객체의 프로퍼티도 아니다.

script 태그에 type=”module” 어트리뷰트를 추가하면 로드된 자바스크립트 파일은 모듈로서 동작한다. 확장자는 mjs를 권장한다.

```jsx
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>
```
