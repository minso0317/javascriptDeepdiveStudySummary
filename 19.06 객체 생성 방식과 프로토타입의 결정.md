다양한 객체 생성 방법

- 객체 리터럴
- Object 생성자 함수
- 생성자 함수
- Object.create 메서드
- 클래스(ES6)

다양한 방식마다 세부적인 객체 생성 방식은 다르나 추상 연산 OrdinaryObjectCreate에 의해 생성되는 공통점이 있다.

추상 연산 OrdinaryObjectCreate는 빈 객체를 생성한 후, 객체에 추가할 프로퍼티 목록이 인수로 전달된 경우 프로퍼티를 객체에 추가한다.

인수로 전달받은 프로토타입을 자신이 생성한 객체 Prototype 내부 슬롯에 할단한 후 생성한 객체를 반환한다.

즉, 프로토타입은 추상 연산 OrdinaryObjectCreate에 전달되는 인수에 의해 결정된다. 이 인수는 객체가 생성되는 시점에 객체 생성 방식에 의해 결정된다.
<br><br>

### 19.6.1 객체 리터럴에 의해 생성된 객체의 프로토타입

자바스크립트 엔진은 객체 리터럴을 평가하여 객체를 생성할 때 추상 연산 OrdinaryObjectCreate를 호출한다. 이때 전달되는 프로토타입은 Object.prototype이다.

즉, 객체 리터럴에 의해 생성되는 객체의 프로토타입은 Object.prototype이다.

```jsx
const onj = { x: 1 };
```

<div align=center><img width="547" alt="19-14" src="https://github.com/user-attachments/assets/23e105da-81e6-4424-8455-4dc346084eba" /></div>

객체 리터럴에 의해 생성된 obj객체는 Object.prototype을 프로토타입으로 갖고, Object.prototype을 상속받는다.

obj 객체는 자신의 프로토타입인 Object.prototype의 constructor 프로퍼티 hasOwnProperty 메서드를 자신의 자산처럼 자유롭게 사용할 수 있다.

```jsx
const obj = { x: 1 };

// 객체 리터럴에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x'));    // true
```

<br><br>


### 19.6.2 Object 생성자 함수에 의해 생성된 객체의 프로토타입

Object 생성자 함수를 인수 없이 호출하면 빈 객체가 생성된다. 

이를 호출하면 추상 연산 OrdinaryObjectCreate가 호출된다.

이때 추상 연산 OrdinaryObjectCreate에 전달되는 프로토타입은 Object.prototype이다.

```jsx
const obj = new Object();
obj.x = 1;
```

위 코드가 실행되면 추상 연산 OrdinaryObjectCreate에 의해 Object 생성자 함수와 Object.prototype과 생성된 객체 사이에 연결이 만들어 진다.

객체 리터럴에 의해 생성된 객체와 동일한 구조르르 갖는다.

<div align=center><img width="560" alt="19-15" src="https://github.com/user-attachments/assets/c8b49dc1-3205-4ab2-8ba8-5db79a5d7846" /></div>

obj 객체는 Object.prototype을 프로토타입으로 갖고, Object.prototype을 상속받는다.

```jsx
const obj = new Object();
obj.x = 1;

// Object 생성자 함수에 의해 생성된 obj 객체는 Object.prototype을 상속받는다.
console.log(obj.constructor === Object); // true
console.log(obj.hasOwnProperty('x'));    // true
```

객체 리터럴과 Object 생성자 함수에 의한 객체 생성 방식의 차이는 프로퍼티를 추가하는 방식에 있다.

객체 리터럴 방식은 객체 리터럴 내부에 프로퍼티를 추가하지만, Object 생성자 함수 방식은 일단 빈 객체를 생성한 후 프로퍼티를 추가해야 한다.
<br><br>

### 19.6.3 생성자 함수에 의해 생성된 객체의 프로토타입

new 연산자와 함께 생성자 함수를 호출해 인스턴스를 생성하면 추상 연산 OrdinaryObjectCreate가 호출되고 프로토타입은 생성자 함수의 prototype 프로퍼티에 바인딩되어 있는 객체다.

```jsx
function Person(name) {
  this.name = name;
}

const me = new Person('Lee');
```

<div align=center><img width="595" alt="19-16" src="https://github.com/user-attachments/assets/b6df3c3a-f992-4454-8c27-95e80fabd075" /></div>

사용자 정의 생성자 함수 Person과 생성된 프로토타입 Person.prototype의 프로퍼티는 connstructor뿐이다.

프로토타입 Person.prototype에 프로퍼티를 추가해 하위 객체가 상속 받도록 구현할 수 있다.

프로토타입은 객체이므로 일반 객체처럼 프로토타입도 프로퍼티를 추가/삭제할 수 있고 프로토타입 체인에 즉각 반영된다.

```jsx
function Person(name) {
  this.name = name;
}

// 프로토타입 메서드
Person.prototype.sayHello = function () {
  console.log(`Hi! My name is ${this.name}`);
};

const me = new Person('Lee');
const you = new Person('Kim');

me.sayHello();  // Hi! My name is Lee
you.sayHello(); // Hi! My name is Kim
```

Person 생성자 함수를 통해 생성된 모든 객체는 프로토타입에 추가된 sayHello 메서드를 상속받아 자신의 메서드처럼 사용할 수 있다.

<div align=center><img width="615" alt="19-17" src="https://github.com/user-attachments/assets/e5004d77-430a-4bd4-b23e-860b3a29fbb0" /></div>
