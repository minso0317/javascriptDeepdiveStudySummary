재할당이란 이미 값이 할당되어 있는 변수에 새로운 값을 또다시 할당 하는것

```jsx
var score = 80; // 변수는 선언과 동시에 undefined로 초기화되어 있으므로 첫 할당도 사실 재할당이다.
score = 90; //재할당
```

값을 재할당할 수 있어서 변수, 그렇지 않고 변수에 저장된 값을 변경할 수 없다면 변수가 아니라 상수(constant)이다.(상수는 한번만 할당할 수 있는 변수이다.)

재할당 역시 처음 할당된 값이 저장되어있던 메모리 공간을 지우는 것이 아니라 새로운 메모리 공간을 확보하고 그 메모리 공간에 새로운 값을 저장한다. 

<div align=center><img src="https://github.com/user-attachments/assets/8526a6d4-708c-4a3f-915e-3c018420e285" width="500" alt="값의 재할당"></div>

재할당 후, 어떠한 식별자에도 연결되어 있지 않은 80, undefined는 가라지 콜렉터에 의해 메모리에서 자동 해제된다(시기는 예측불가)

자바스크립트는 가비지 콜렉터를 내장하고 있는 매니지드 언어로 이를 통해 메모리 누수(memory leak)를 방지한다.

| 언매니지드언어(unmanaged language) | 매니지드언어(managed language) |
| --- | --- |
| 대표언어: C 언어 | 대표언어: Javascript |
| - 개발자가 명시적으로 메모리 할당, 해제를 위해 mall()과 free 같은 저수준(low-level)메모리 제어 기능 제공 | - 메모리 할당 및 해제를 위한 메모리 관리 기능을 언어 차원에서 당당하여 개발자의 직접적인 메모리 제어를 불허  |
| - 메모리 제어를 개발자가 주도할 수 있어 개발자의 역량에 따라 최적의 성능 확보 가능 | - 메모리 해제는 가비지 콜렉터가 수행, 이 또한 개발자가 관여할 수 없다. |
| - 그렇지 못한다면 오류 생산할 가능성도 있다. | - 일정한 생산성을 확보할 수 있지만, 성능면에서 어느 정도의 손실은 감수할 수 밖에 없다. |
