세미콜론(;)은 문의 종료를 나타냄.

자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악, 순차적으로 하나씩 문을 실행함.

단, 0개 이상의 문을 중괄호로 묶은 코드 블록 { } 은 뒤에 세미콜론을 붙이지 않는다.

예, if문, 조건문, 함수 등의 코드 블록 뒤는 세미콜론 붙이지 않는다. 이들의 코드 블록은 문의 종료 후 자체 종결성을 갖는다.

세미콜론 자동 사입 기능(ASI)이 있어서 세미콜론 생략 가능. 간혹 개발자의 예측과 ASI의 동작이 다를때가 있다.

```jsx
function foo () {
  return
  {}
                                     // ASI의 동작 결과 => return; {};
                                     // 개발자의 예측 => return {}; (나도..)
}
console.log(foo()); // undefined

=====================================================================

var bar = function () {}
(function() {})();

// ASI의 동작 결과 => var bar = function () {} (function() {}(); (나.. ??)
// 개발자의 예측 => var bar = function () {}; (function() {}();
// TypeError: (inermediate value)(...) is not a function.

(function() {})();에서 SyntaxError가 발생해.
자바스크립트는 function()을 함수 선언문으로 해석하려고 하는데, 함수 선언문은 단독으로 실행될 수 없어
```

개발자의 생각대로 

var bar = function () {}; 

(function() {}();

이렇게 세미콜론이 나눠지면 두개의 다른 표현식이 되어 undefined로 출력되지만

ASI는 var bar = function () {} (function() {}(); 로 동작을 해서

하나의 이어진 표현식으로 만든다. 즉 줄바꿈이 되어있지만, 세미콜론으로 function() {}를 명확히 끝내주지 않아서 계속해서 이어진 하나의 표현식으로 동작시킴.

그래서 bar는 함수가 아닌 function() {} 그 자체인데 뒤의 (function() {})();를 붙히려 해서 Type Error가 발생.

자바스크립트는 function()을 함수 선언문으로 해석하려고 하는데, 함수 선언문은 단독으로 실행될 수 없다.

```jsx
var bar = function () {};
(function() {}());  
```

이렇게 하면 **즉시 실행 함수 표현식(IIFE)**로 인식돼서 정상 실행된다.

이유:

자바스크립트에서 **함수 선언문(Function Declaration)과 함수 표현식(Function Expression)의 차이** 때문에 IIFE가 올바르게 실행된다

.

```jsx
function foo() {}  // 함수 선언문(Function Declaration)
var bar = function() {}; // 함수 표현식(Function Expression)
```

함수 선언문은 `function` 키워드가 코드의 시작 부분에 올 경우 발생하는데, 항상 식별자(이름)가 필요.
함수 표현식은 `function`이 변수에 할당되거나, 즉시 실행되면 표현식(Expression)으로 간주.
